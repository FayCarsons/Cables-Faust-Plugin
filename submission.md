# Faust Cables.gl Plugin

This Google Summer of Code program aimed to create a [Faust](https://faust.grame.fr) plugin for the [Cables.gl](https://cables.gl) platform, an in-browser visual programming environment similar to Max MSP or Pure Data. 
This takes the form of a Cables 'operator', a single contained app which can interface with other operators in a cables patch via audio and control signals.

This Faust operator enables Cables users to write boilerplate-free DSP programs that are embedded in and integrate with the other audio-visual elements of their Cables patches.

# Contributions 

My work on this project consists largely of integrating the [faustwasm](https://github.com/grame-cncm/faustwasm) library with Cables' operator API. Cables shares the source code of the operators in its standard library so a large part of my work was extrapolating from relevant examples within that to decide the Faust operator's architecture.

The primary areas of focus were:
  
### Creating dynamic ports

A 'port' is an input or output on a Cables operator, signals of any Javascript type can be sent and received via the 'cables' that connect one operator's output to another operator's input. 
In the case of the Faust operator these ports represent parameters of the Faust program being run, audio IO, or MIDI. When considering the question of whether ports should be static, where the operator instantiating with a handful of ports of each type, or dynamic, where ports are generated based on the parameters of the Faust program being run, it was abundantly clear that dynamic ports were the only option that would allow for a decent UX.

Initially, my mentors and I were unsure that this was even possible. I'm not sure that it is something that Cables encourages, but with the alternative being so awkward and limiting I continued to look for examples of this being done. Eventually, I found Cables' `CustomShader` operator, which generates new ports for the GLSL uniforms (inputs, essentially) you add to your shader. With that operator as a reference I designed a [state management system ](../main/src/porthandler.js) which processes the Web Audio node generated by Faustwasm, walking the internal metadata tree and accumulating the necessary data until the operator's state matches the node's.

### MIDI and polyphony

There are 4 kinds of signals that the Faust operator, and most DSP programs in general, can accept. Floating point numbers, triggers, audio, and MIDI. Numbers and triggers are trivial, when users script declares a number or trigger parameter: 

```dsp 
numberParam = hslider("numberInput", 1, 0, 2, 0.1);
triggerParam = button("triggerInput");
```

corresponding `number` or `trig` ports are created on the operator. But in the case of MIDI integration, a few different constraints need to be satisfied:

1. MIDI parameters should be able to exist in parallel to audio or non-MIDI control parameters 
2. Parameters explicitly marked as MIDI-controlled should not have individual ports created but folded into one MIDI port 
3. When a polyphonic synthesizer is instantiated, it should contain the [required parameters](https://faustdoc.grame.fr/manual/midi/#standard-polyphony-parameters) which are automagically marked as MIDI-controlled and connected to the MIDI port 

Handling these constraints made up a large part of the operator's state management system. I wanted to reduce modality as much as possible, discrete states which must be controlled by the user or are predicated on many small dynamic sources of state opens us up to error and makes for a bad UX as they increase in number.

Having to declare MIDI parameters in your Faust program and then also hit the "MIDI mode" button is less than ideal. This also relates back to point 1, in a discrete "MIDI mode" how are other control signals treated? Can they be present at all? Is that another special case? How many special cases do you have now? All of these problems and the complexity that follows can be avoided by orienting things hierarchically, where the main input, in this case the Faust program, dictates all other state as opposed to a horizontal collection of inputs which all affect state in small ways.

### JavaScript and the functional paradigm

I have been teaching myself to code for roughly 2 years, and in that time have written statically-typed mostly-pure functional code almost exclusively. Out of the available paradigms it is the obvious choice and maps most clearly to my understanding of the world. I encountered Faust through a desire to merge functional programming and audio synthesis, my main hobbies, and from there found myself applying to GSoC. 

It was sort of a rude awakening when I started on the project and found that Cables' operator API disallowed functional programming *and* required the use of global mutable state, generally discouraged even non-functional. Everything had to be instantiated at the top-level of the namespace, and then updated through callbacks. This and the lack of a type system caused me the most struggle in this project.

I sometimes joke that I am not smart enough for dynamic languages, I need a type system to tell me when I've forgotten arguments, or a field access, or simply put the wrong thing in the wrong place. I lost a few weeks wrestling with the core state-management of the app, eventually giving up any semblance of my usual programming style in favor of the style that Cables wanted me to write. Everything was refactored in an OOP style, all functionality clearly delimited by classes. I added named arguments, default values for arguments where necessary, and getter/setter functions which allowed for logging updates more easily. This reduced non-deterministic behavior enough that I was able to get some stability and, after a couple of weeks, the core of the app was finished. 

If I learned something from this I think it would be to be more flexible, to work within the parameters my environment asks me to, because bending things to match my own taste can be more trouble than its worth. Paradigms are ultimately style, in the end it all becomes imperative machine code and its valuable to understand how to work with, not against, that. I anticipate having to work with languages and paradigms that are not my first choice, on software that is not elegant or bug-free, in my career and I've gained useful experience doing that from this project.

### Going forward

For the most part, all the features I set out to implement have been finished. The app is maybe not as robust as I would like, which is my first instinct as far as "what to do next". Beyond that, I'll list out some features I wish I could have added: 

- Using WebGL buffers as Faust waveforms or soundfiles
- Control signal outputs from the Faust program, I.E. outputting the amplitude of the current synth to be used in visuals
- Gyroscope and accelerometer support 
- The ability to output the audio buffer so it can be used in shader programs

## Conclusion

Working on this project has reminded me how much fun it is to write DSP and graphics programs, and inspired me to start writing both again in my free time. Faust is an incredible piece of software which I have only scratched the surface of and I'm eager to integrate it with the personal projects I have planned. Cables is a great way to sketch out audio-reactive shader programs and hopefully, with the addition of this operator, a great way to quickly build and play synthesizers. 

Thank you to Thomas Rushton, Stephane Letz, and Tobias Hartmann for their guidance regarding architecture, Faust, and Cables throughout this project.

