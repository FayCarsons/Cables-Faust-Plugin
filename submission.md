# Faust Cables.gl Plugin

This Google Summer of Code program aimed to create a Faust plugin for the Cables.gl platform, an in-browser visual programming environment similar to Max MSP or Pure Data. 
This plugin takes the form of a Cables 'operator', a single contained app which can interface with other operators in a cables patch via audio and control signals.

This Faust operator enables Cables users to write boilerplate-free DSP programs that are embedded in and integrate with the other audio-visual elements of their Cables patches.

# Contributions 

My work on this project consists largely of integrating the [faustwasm](https://github.com/grame-cncm/faustwasm) library with Cables' operator API. Cables shares the source code of the operators in its standard library so a large part of my work was extrapolating from relevant examples to decide the Faust operator's architecture.

The primary areas of focus were:
  
### Creating dynamic ports

A 'port' is an input or output on a Cables operator, signals of any Javascript type can be sent and received via the 'cables' that connect one operator's output to another operator's input. 
In the case of the Faust operator these ports represent parameters of the Faust program being run, audio IO, or MIDI. When considering the question of whether ports should be static, where the operator instantiating with a handful of ports of each type, or dynamic, where ports are generated based on the parameters of the Faust program being run, it was abundantly clear that dynamic was the only option that would allow for a decent UX.

This necessitated the design of a [state management system for the operator's ports](../main/src/porthandler.js) which processes the Web Audio node generated by Faustwasm, walking the internal metadata tree and accumulating the necessary data.

### MIDI and polyphony

There are 4 kinds of signals that the Faust operator, most DSP programs in general, can accept. Floating point numbers, triggers, audio, and MIDI. Numbers and triggers are trivial, when users script declares a number or trigger parameter: 

```dsp 
numberParam = hslider("numberInput", 1, 0, 2, 0.1);
triggerParam = button("triggerInput");
```

corresponding `number` or `trig` ports are created on the operator. But in the case of MIDI integration, a few different constraints need to be satisfied:

1. MIDI parameters should be able to exist in parallel to audio or non-MIDI control parameters 
2. Parameters explicitly marked as MIDI-controlled should not have individual ports created but folded into one MIDI port 
3. When a polyphonic synthesizer is instantiated, it should contain the [required parameters](https://faustdoc.grame.fr/manual/midi/#standard-polyphony-parameters) which are automagically marked as MIDI-controlled and connected to the MIDI port 

Handling these constraints made up a large part of the operator's state management system. I wanted to reduce modality and keep things "bottom-up" as much as possible, discrete states which must be controlled by the user in a "top-down" way or are predicated on dynamic state opens us up to error and makes for a bad UX as they increase in number.

Having to declare MIDI parameters in your Faust program and then also hit the "MIDI mode" button is less than ideal. This also relates back to point 1,  in a discrete "MIDI mode" how are other control signals treated? Can they be present at all? Is that another special case? This approach does not lead one to good design.

### Javascript and impure updates

I have been teaching myself to code for roughly 2 years, and in that time have written statically-typed mostly-pure functional code almost exclusively. Out of the available paradigms it is the obvious choice and maps most clearly to my understanding of the world. I encountered Faust through a desire to merge functional programming and audio synthesis, my main hobbies, and from there found myself applying to GSoC. It was sort of a rude awakening when I began work and found that Cables' architecture disallowed functional programming *and* required the use of global mutable state, which is generally discouraged even in paradigms that allow for mutation. Everything had to be instantiated at the top-level of the namespace, and then updated through callbacks. This and the lack of a type system caused the most struggle in the project.

I sometimes joke that I am not smart enough for dynamic languages, I need a type system to tell me when I've forgotten arguments, or a field access, or simply put the wrong thing in the wrong place. I lost a few weeks wrestling with the core state-management of the app, eventually giving up any semblance of my usual programming style in favor of the style that Cables wanted me to write. I rewrote everything in a more OOP style, all functionality clearly delimited by classes. I added named arguments, default values for arguments where necessary, and getter/setter functions which allowed for logging updates more easily.

Beyond that, Cables is entirely in-browser. There is no way to import a file from GitHub and run it as an operator. All dependencies must be added as plain-text attachments. Updating these files can also be error-prone, with operators glitching and discarding the text you hand-pasted in, editor windows becoming disconnected from the file you are editing and ignoring your input. Your patches shift and change, things that worked do not work when revisited. Lots of unexpected non-deterministic behavior, which is to be expected from a small free-to-use (and as of recently, open-source) project but makes developing difficult.

If I learned something from this I think it would be to be more flexible, to work within the parameters my environment asks me to, because bending things to match my own taste can be more trouble than its worth. Paradigms are ultimately style, in the end it all becomes imperative machine code and its valuable to understand how to work with, not against, that. I anticipate having to work with languages and paradigms that are not my first choice, on software that is not elegant or bug-free, in my career and I've gained useful experience doing that from this project.

### Going forward

For the most part, all the features I set out to implement have been finished. The app is maybe not as robust as I would like, which would be my first instinct as far as "what to do next" goes. Beyond that, I'll list out some features I wish I could have added: 

- Using WebGL buffers as Faust waveforms or soundfiles
- Control signal outputs from the Faust program, I.E. outputting the amplitude of the current synth to be used in visuals
- Gyroscope and accelerometer support 
- The ability to output the audio buffer so it can be used in shader programs

## Conclusion

Working on this project has reminded me how much fun it is to write DSP and graphics programs, and inspired me to start writing both again in my free time. Faust is an incredible piece of software of which I have only scratched the surface and I'm eager to integrate it with the personal projects I have planned. Cables is a great way to sketch out audio-reactive shader programs and hopefully, with the addition of this operator, a great way to quickly build and play synthesizers. 

Thank you to Thomas Rushton, Stephane Letz, and Tobias Hartmann for their guidance regarding architecture, Faust, and Cables throughout this project.

